create extension if not exists "pg_trgm" with schema "public" version '1.6';

create extension if not exists "vector" with schema "public" version '0.8.0';

create type "public"."image_status" as enum ('pending', 'processing', 'completed', 'failed');

create table "public"."Amethyst" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."Amethyst" enable row level security;

create table "public"."ad_views" (
    "id" uuid not null default uuid_generate_v4(),
    "profile_id" uuid,
    "ad_id" text not null,
    "view_duration" integer,
    "completed" boolean default false,
    "created_at" timestamp without time zone default now(),
    "credits_earned" integer default 0,
    "metadata" jsonb
);


alter table "public"."ad_views" enable row level security;

create table "public"."ads_history" (
    "id" uuid not null default uuid_generate_v4(),
    "profile_id" uuid,
    "ad_id" text not null,
    "credits_earned" integer not null,
    "watched_at" timestamp without time zone default now(),
    "watched_duration" integer,
    "completed" boolean default false,
    "platform" text,
    "metadata" jsonb
);


alter table "public"."ads_history" enable row level security;

create table "public"."collection_images" (
    "collection_id" uuid not null,
    "image_id" uuid not null,
    "added_at" timestamp with time zone not null default timezone('utc'::text, now())
);


create table "public"."credit_sources" (
    "id" uuid not null default uuid_generate_v4(),
    "profile_id" uuid,
    "type" text not null,
    "amount" integer not null,
    "created_at" timestamp without time zone default now(),
    "expires_at" timestamp without time zone,
    "metadata" jsonb
);


alter table "public"."credit_sources" enable row level security;

create table "public"."credits_transactions" (
    "id" uuid not null default uuid_generate_v4(),
    "profile_id" uuid,
    "amount" integer not null,
    "type" text not null,
    "description" text,
    "created_at" timestamp without time zone default now(),
    "metadata" jsonb
);


alter table "public"."credits_transactions" enable row level security;

create table "public"."generated_images" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "image_id" uuid,
    "prompt" text not null,
    "negative_prompt" text default ''::text,
    "width" integer not null default 512,
    "height" integer not null default 512,
    "num_inference_steps" integer not null default 20,
    "guidance_scale" double precision not null default 7.5,
    "seed" bigint,
    "scheduler" text default 'DPMSolverMultistep'::text,
    "strength" double precision default 1.0,
    "num_outputs" integer default 1,
    "aspect_ratio" text default '1:1'::text,
    "output_format" text not null default 'png'::text,
    "output_quality" integer default 100,
    "prompt_strength" double precision default 0.8,
    "hf_loras" text[] default ARRAY[]::text[],
    "lora_scales" double precision[] default ARRAY[]::double precision[],
    "disable_safety_checker" boolean default false,
    "reference_image_id" uuid,
    "reference_image_strength" double precision default 0.75,
    "model_version" text default 'SDXL 1.0'::text,
    "generation_time" double precision,
    "status" image_status default 'pending'::image_status,
    "error_message" text,
    "raw_parameters" jsonb default '{}'::jsonb,
    "parameter_history" jsonb[] default ARRAY[]::jsonb[],
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone
);


alter table "public"."generated_images" enable row level security;

create table "public"."image_collections" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "name" text not null,
    "description" text,
    "is_public" boolean default false,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."image_collections" enable row level security;

create table "public"."image_metadata" (
    "image_id" uuid not null,
    "vision_labels" jsonb default '{}'::jsonb,
    "vision_objects" jsonb default '{}'::jsonb,
    "vision_text" text,
    "vision_colors" jsonb default '{}'::jsonb,
    "embedding" vector(512),
    "style_embedding" vector(256),
    "content_embedding" vector(256),
    "confidence_score" double precision,
    "nsfw_score" double precision,
    "processing_status" image_status default 'pending'::image_status,
    "processed_at" timestamp with time zone,
    "error_message" text,
    "raw_analysis_result" jsonb default '{}'::jsonb
);


create table "public"."images" (
    "id" uuid not null default gen_random_uuid(),
    "hash" text not null,
    "storage_path" text not null,
    "public_url" text,
    "width" integer not null,
    "height" integer not null,
    "format" text not null,
    "file_size_bytes" bigint not null,
    "is_nsfw" boolean default false,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "metadata" jsonb default '{}'::jsonb
);


create table "public"."oauth_tokens" (
    "profile_id" uuid,
    "provider" text not null,
    "access_token" text,
    "refresh_token" text,
    "expires_at" timestamp without time zone,
    "scope" text[]
);


alter table "public"."oauth_tokens" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "email" text,
    "is_admin" boolean default false,
    "is_banned" boolean default false,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "last_sign_in_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "full_name" text,
    "phone_number" text,
    "avatar_url" text,
    "auth_provider" text,
    "provider_id" text,
    "subscription_tier" text default 'free'::text,
    "subscription_status" text default 'active'::text,
    "subscription_end_date" timestamp without time zone,
    "stripe_customer_id" text,
    "credits_balance" integer default 0,
    "lifetime_credits" integer default 0,
    "last_credit_update" timestamp without time zone default now(),
    "language" text default 'fr'::text,
    "theme" text default 'light'::text,
    "notifications_enabled" boolean default true,
    "marketing_emails_enabled" boolean default true,
    "ads_enabled" boolean default true,
    "ads_credits_earned" integer default 0,
    "ads_watched_today" integer default 0,
    "ads_last_watched" timestamp without time zone,
    "daily_ads_limit" integer default 10,
    "google_id" text,
    "apple_id" text,
    "github_id" text,
    "email_verified" boolean default false,
    "phone_verified" boolean default false
);


alter table "public"."profiles" enable row level security;

create table "public"."prompts" (
    "id" uuid not null default uuid_generate_v4(),
    "user_id" uuid,
    "prompt" text not null,
    "negative_prompt" text default ''::text,
    "aspect_ratio" text not null default '1:1'::text,
    "prompt_strength" double precision not null default 0.8,
    "steps" integer not null default 28,
    "guidance_scale" double precision not null default 7.5,
    "num_outputs" integer not null default 1,
    "seed" integer not null default '-1'::integer,
    "output_format" text not null default 'webp'::text,
    "output_quality" integer not null default 90,
    "safety_checker" boolean not null default true,
    "hf_loras" text[] not null default ARRAY['AndyVampiro/fog'::text],
    "lora_scales" double precision[] not null default ARRAY[1.0],
    "created_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."prompts" enable row level security;

create table "public"."reference_images" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "image_id" uuid,
    "original_filename" text,
    "purpose" text default 'reference'::text,
    "preprocessing_applied" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "last_used_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "usage_count" integer default 0
);


alter table "public"."reference_images" enable row level security;

create table "public"."subscription_history" (
    "id" uuid not null default uuid_generate_v4(),
    "profile_id" uuid,
    "tier" text not null,
    "status" text not null,
    "start_date" timestamp without time zone default now(),
    "end_date" timestamp without time zone,
    "payment_method" text,
    "amount" numeric,
    "currency" text default 'EUR'::text,
    "metadata" jsonb
);


alter table "public"."subscription_history" enable row level security;

CREATE UNIQUE INDEX "Amethyst_pkey" ON public."Amethyst" USING btree (id);

CREATE UNIQUE INDEX ad_views_pkey ON public.ad_views USING btree (id);

CREATE UNIQUE INDEX ads_history_pkey ON public.ads_history USING btree (id);

CREATE UNIQUE INDEX collection_images_pkey ON public.collection_images USING btree (collection_id, image_id);

CREATE UNIQUE INDEX credit_sources_pkey ON public.credit_sources USING btree (id);

CREATE UNIQUE INDEX credits_transactions_pkey ON public.credits_transactions USING btree (id);

CREATE UNIQUE INDEX generated_images_pkey ON public.generated_images USING btree (id);

CREATE INDEX idx_ad_views_date ON public.ad_views USING btree (created_at);

CREATE INDEX idx_ad_views_profile ON public.ad_views USING btree (profile_id);

CREATE INDEX idx_ads_history_date ON public.ads_history USING btree (watched_at);

CREATE INDEX idx_ads_history_profile ON public.ads_history USING btree (profile_id);

CREATE INDEX idx_collection_images_added ON public.collection_images USING btree (added_at);

CREATE INDEX idx_collections_public ON public.image_collections USING btree (is_public) WHERE (is_public = true);

CREATE INDEX idx_credit_sources_profile ON public.credit_sources USING btree (profile_id);

CREATE INDEX idx_credits_transactions_profile ON public.credits_transactions USING btree (profile_id);

CREATE INDEX idx_generated_images_completed ON public.generated_images USING btree (completed_at) WHERE (status = 'completed'::image_status);

CREATE INDEX idx_generated_images_created ON public.generated_images USING btree (created_at);

CREATE INDEX idx_generated_images_generation_time ON public.generated_images USING btree (generation_time);

CREATE INDEX idx_generated_images_model ON public.generated_images USING btree (model_version, created_at);

CREATE INDEX idx_generated_images_negative_prompt_trigram ON public.generated_images USING gist (negative_prompt gist_trgm_ops);

CREATE INDEX idx_generated_images_processing ON public.generated_images USING btree (started_at) WHERE (status = 'processing'::image_status);

CREATE INDEX idx_generated_images_prompt_trigram ON public.generated_images USING gist (prompt gist_trgm_ops);

CREATE INDEX idx_generated_images_user ON public.generated_images USING btree (user_id);

CREATE INDEX idx_generated_images_user_status ON public.generated_images USING btree (user_id, status);

CREATE INDEX idx_image_metadata_content ON public.image_metadata USING ivfflat (content_embedding vector_cosine_ops);

CREATE INDEX idx_image_metadata_embedding ON public.image_metadata USING ivfflat (embedding vector_cosine_ops);

CREATE INDEX idx_image_metadata_nsfw_score ON public.image_metadata USING btree (nsfw_score) WHERE (nsfw_score > (0.5)::double precision);

CREATE INDEX idx_image_metadata_style ON public.image_metadata USING ivfflat (style_embedding vector_cosine_ops);

CREATE INDEX idx_image_metadata_vision_labels ON public.image_metadata USING gin (vision_labels jsonb_path_ops);

CREATE INDEX idx_image_metadata_vision_objects ON public.image_metadata USING gin (vision_objects jsonb_path_ops);

CREATE INDEX idx_images_format_size ON public.images USING btree (format, file_size_bytes);

CREATE INDEX idx_images_hash ON public.images USING btree (hash);

CREATE INDEX idx_images_metadata ON public.images USING gin (metadata jsonb_path_ops);

CREATE INDEX idx_images_nsfw ON public.images USING btree (is_nsfw) WHERE (is_nsfw = true);

CREATE INDEX idx_oauth_tokens_profile ON public.oauth_tokens USING btree (profile_id, provider);

CREATE INDEX idx_profiles_email ON public.profiles USING btree (email);

CREATE INDEX idx_profiles_subscription ON public.profiles USING btree (subscription_tier, subscription_status);

CREATE INDEX idx_reference_images_last_used ON public.reference_images USING btree (last_used_at);

CREATE INDEX idx_reference_images_usage_count ON public.reference_images USING btree (usage_count);

CREATE INDEX idx_reference_images_user ON public.reference_images USING btree (user_id);

CREATE INDEX idx_subscription_history_profile ON public.subscription_history USING btree (profile_id);

CREATE UNIQUE INDEX image_collections_pkey ON public.image_collections USING btree (id);

CREATE UNIQUE INDEX image_metadata_pkey ON public.image_metadata USING btree (image_id);

CREATE UNIQUE INDEX images_hash_key ON public.images USING btree (hash);

CREATE UNIQUE INDEX images_pkey ON public.images USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX prompts_pkey ON public.prompts USING btree (id);

CREATE UNIQUE INDEX reference_images_pkey ON public.reference_images USING btree (id);

CREATE UNIQUE INDEX subscription_history_pkey ON public.subscription_history USING btree (id);

alter table "public"."Amethyst" add constraint "Amethyst_pkey" PRIMARY KEY using index "Amethyst_pkey";

alter table "public"."ad_views" add constraint "ad_views_pkey" PRIMARY KEY using index "ad_views_pkey";

alter table "public"."ads_history" add constraint "ads_history_pkey" PRIMARY KEY using index "ads_history_pkey";

alter table "public"."collection_images" add constraint "collection_images_pkey" PRIMARY KEY using index "collection_images_pkey";

alter table "public"."credit_sources" add constraint "credit_sources_pkey" PRIMARY KEY using index "credit_sources_pkey";

alter table "public"."credits_transactions" add constraint "credits_transactions_pkey" PRIMARY KEY using index "credits_transactions_pkey";

alter table "public"."generated_images" add constraint "generated_images_pkey" PRIMARY KEY using index "generated_images_pkey";

alter table "public"."image_collections" add constraint "image_collections_pkey" PRIMARY KEY using index "image_collections_pkey";

alter table "public"."image_metadata" add constraint "image_metadata_pkey" PRIMARY KEY using index "image_metadata_pkey";

alter table "public"."images" add constraint "images_pkey" PRIMARY KEY using index "images_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."prompts" add constraint "prompts_pkey" PRIMARY KEY using index "prompts_pkey";

alter table "public"."reference_images" add constraint "reference_images_pkey" PRIMARY KEY using index "reference_images_pkey";

alter table "public"."subscription_history" add constraint "subscription_history_pkey" PRIMARY KEY using index "subscription_history_pkey";

alter table "public"."ad_views" add constraint "ad_views_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."ad_views" validate constraint "ad_views_profile_id_fkey";

alter table "public"."ads_history" add constraint "ads_history_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."ads_history" validate constraint "ads_history_profile_id_fkey";

alter table "public"."ads_history" add constraint "valid_platform" CHECK ((platform = ANY (ARRAY['web'::text, 'mobile'::text, 'desktop'::text]))) not valid;

alter table "public"."ads_history" validate constraint "valid_platform";

alter table "public"."collection_images" add constraint "collection_images_collection_id_fkey" FOREIGN KEY (collection_id) REFERENCES image_collections(id) ON DELETE CASCADE not valid;

alter table "public"."collection_images" validate constraint "collection_images_collection_id_fkey";

alter table "public"."collection_images" add constraint "collection_images_image_id_fkey" FOREIGN KEY (image_id) REFERENCES images(id) ON DELETE CASCADE not valid;

alter table "public"."collection_images" validate constraint "collection_images_image_id_fkey";

alter table "public"."credit_sources" add constraint "credit_sources_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."credit_sources" validate constraint "credit_sources_profile_id_fkey";

alter table "public"."credit_sources" add constraint "valid_credit_source_type" CHECK ((type = ANY (ARRAY['ad_view'::text, 'ad_click'::text, 'stripe_purchase'::text, 'reward'::text]))) not valid;

alter table "public"."credit_sources" validate constraint "valid_credit_source_type";

alter table "public"."credits_transactions" add constraint "credits_transactions_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."credits_transactions" validate constraint "credits_transactions_profile_id_fkey";

alter table "public"."credits_transactions" add constraint "valid_transaction_type" CHECK ((type = ANY (ARRAY['purchase'::text, 'reward'::text, 'usage'::text, 'refund'::text]))) not valid;

alter table "public"."credits_transactions" validate constraint "valid_transaction_type";

alter table "public"."generated_images" add constraint "generated_images_image_id_fkey" FOREIGN KEY (image_id) REFERENCES images(id) ON DELETE RESTRICT not valid;

alter table "public"."generated_images" validate constraint "generated_images_image_id_fkey";

alter table "public"."generated_images" add constraint "generated_images_reference_image_id_fkey" FOREIGN KEY (reference_image_id) REFERENCES images(id) not valid;

alter table "public"."generated_images" validate constraint "generated_images_reference_image_id_fkey";

alter table "public"."generated_images" add constraint "generated_images_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."generated_images" validate constraint "generated_images_user_id_fkey";

alter table "public"."image_collections" add constraint "image_collections_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."image_collections" validate constraint "image_collections_user_id_fkey";

alter table "public"."image_metadata" add constraint "image_metadata_image_id_fkey" FOREIGN KEY (image_id) REFERENCES images(id) ON DELETE CASCADE not valid;

alter table "public"."image_metadata" validate constraint "image_metadata_image_id_fkey";

alter table "public"."images" add constraint "images_hash_key" UNIQUE using index "images_hash_key";

alter table "public"."oauth_tokens" add constraint "oauth_tokens_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."oauth_tokens" validate constraint "oauth_tokens_profile_id_fkey";

alter table "public"."oauth_tokens" add constraint "valid_provider" CHECK ((provider = ANY (ARRAY['google'::text, 'apple'::text, 'github'::text]))) not valid;

alter table "public"."oauth_tokens" validate constraint "valid_provider";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."prompts" add constraint "guidance_scale_range" CHECK (((guidance_scale >= (1.0)::double precision) AND (guidance_scale <= (20.0)::double precision))) not valid;

alter table "public"."prompts" validate constraint "guidance_scale_range";

alter table "public"."prompts" add constraint "num_outputs_range" CHECK (((num_outputs >= 1) AND (num_outputs <= 4))) not valid;

alter table "public"."prompts" validate constraint "num_outputs_range";

alter table "public"."prompts" add constraint "output_quality_range" CHECK (((output_quality >= 1) AND (output_quality <= 100))) not valid;

alter table "public"."prompts" validate constraint "output_quality_range";

alter table "public"."prompts" add constraint "prompt_strength_range" CHECK (((prompt_strength >= (0.1)::double precision) AND (prompt_strength <= (1.0)::double precision))) not valid;

alter table "public"."prompts" validate constraint "prompt_strength_range";

alter table "public"."prompts" add constraint "prompts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."prompts" validate constraint "prompts_user_id_fkey";

alter table "public"."prompts" add constraint "steps_range" CHECK (((steps >= 1) AND (steps <= 100))) not valid;

alter table "public"."prompts" validate constraint "steps_range";

alter table "public"."prompts" add constraint "valid_aspect_ratio" CHECK ((aspect_ratio = ANY (ARRAY['1:1'::text, '16:9'::text]))) not valid;

alter table "public"."prompts" validate constraint "valid_aspect_ratio";

alter table "public"."reference_images" add constraint "reference_images_image_id_fkey" FOREIGN KEY (image_id) REFERENCES images(id) ON DELETE RESTRICT not valid;

alter table "public"."reference_images" validate constraint "reference_images_image_id_fkey";

alter table "public"."reference_images" add constraint "reference_images_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."reference_images" validate constraint "reference_images_user_id_fkey";

alter table "public"."subscription_history" add constraint "subscription_history_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_history" validate constraint "subscription_history_profile_id_fkey";

alter table "public"."subscription_history" add constraint "valid_subscription_status" CHECK ((status = ANY (ARRAY['active'::text, 'cancelled'::text, 'expired'::text]))) not valid;

alter table "public"."subscription_history" validate constraint "valid_subscription_status";

alter table "public"."subscription_history" add constraint "valid_subscription_tier" CHECK ((tier = ANY (ARRAY['free'::text, 'premium'::text]))) not valid;

alter table "public"."subscription_history" validate constraint "valid_subscription_tier";

set check_function_bodies = off;

create or replace view "public"."active_reference_images" as  SELECT r.id,
    r.user_id,
    r.image_id,
    r.original_filename,
    r.purpose,
    r.preprocessing_applied,
    r.created_at,
    r.last_used_at,
    r.usage_count,
    i.public_url,
    i.width,
    i.height
   FROM (reference_images r
     JOIN images i ON ((r.image_id = i.id)))
  WHERE (r.last_used_at > (now() - '7 days'::interval));


CREATE OR REPLACE FUNCTION public.award_ad_credits(profile_id uuid, ad_id text, view_duration integer, completed boolean)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    credits_to_award integer;
BEGIN
    -- Calcul des crédits en fonction du type de visionnage
    credits_to_award := CASE
        WHEN completed THEN 10  -- Visionnage complet
        WHEN view_duration >= 15 THEN 5  -- Au moins 15 secondes
        ELSE 0
    END;

    -- Enregistrer la vue
    INSERT INTO ad_views (
        profile_id, ad_id, view_duration, completed, credits_earned
    ) VALUES (
        profile_id, ad_id, view_duration, completed, credits_to_award
    );

    -- Si des crédits sont gagnés, les ajouter
    IF credits_to_award > 0 THEN
        -- Enregistrer la source
        INSERT INTO credit_sources (
            profile_id, type, amount, metadata
        ) VALUES (
            profile_id,
            'ad_view',
            credits_to_award,
            jsonb_build_object('ad_id', ad_id, 'duration', view_duration)
        );

        -- Mettre à jour le solde
        PERFORM update_credits_balance(
            profile_id,
            credits_to_award,
            'reward',
            'Crédits gagnés via publicité'
        );
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_admin_status(user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM profiles 
        WHERE id = user_id 
        AND is_admin = true
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_daily_ad_credits_limit(profile_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    daily_credits integer;
    max_daily_credits integer := 50; -- Limite quotidienne
BEGIN
    SELECT COALESCE(SUM(credits_earned), 0)
    INTO daily_credits
    FROM ad_views
    WHERE profile_id = $1
    AND created_at >= CURRENT_DATE;

    RETURN daily_credits < max_daily_credits;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_expired_subscriptions()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    UPDATE profiles
    SET subscription_status = 'expired',
        subscription_tier = 'free'
    WHERE subscription_end_date < now()
    AND subscription_tier != 'free';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_profile_for_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    INSERT INTO public.profiles (
        id,
        email,
        full_name,
        created_at,
        last_sign_in_at,
        credits_balance,
        subscription_tier,
        subscription_status,
        auth_provider,
        language,
        is_admin
    ) VALUES (
        NEW.id,
        NEW.email,
        COALESCE(NEW.raw_user_meta_data->>'full_name', split_part(NEW.email, '@', 1)),
        NEW.created_at,
        NEW.last_sign_in_at,
        100,
        'free',
        'active',
        COALESCE(NEW.app_metadata->>'provider', 'email'),
        'fr',
        COALESCE((NEW.raw_user_meta_data->>'is_admin')::boolean, false)
    );
    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    RAISE LOG 'Erreur dans create_profile_for_user: %', SQLERRM;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.daily_maintenance()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    -- Réinitialiser les compteurs de pubs
    PERFORM reset_daily_ads();
    
    -- Vérifier les abonnements
    PERFORM check_expired_subscriptions();
    
    -- Nettoyer les vieux tokens
    DELETE FROM oauth_tokens 
    WHERE expires_at < now();
    
    -- Attribuer les bonus quotidiens
    UPDATE profiles 
    SET credits_balance = credits_balance + 
        CASE subscription_tier
            WHEN 'premium' THEN 20
            ELSE 5
        END
    WHERE last_sign_in_at > CURRENT_DATE - interval '1 day';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_profile(user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    user_profile json;
BEGIN
    SELECT json_build_object(
        'id', p.id,
        'email', p.email,
        'is_admin', p.is_admin,
        'is_banned', p.is_banned,
        'created_at', p.created_at,
        'last_sign_in_at', p.last_sign_in_at
    ) INTO user_profile
    FROM profiles p
    WHERE p.id = user_id;

    RETURN user_profile;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
    insert into public.profiles (id, username, full_name, avatar_url)
    values (
        new.id,
        new.raw_user_meta_data->>'username',
        new.raw_user_meta_data->>'full_name',
        new.raw_user_meta_data->>'avatar_url'
    );
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.is_admin()
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM profiles
    WHERE id = auth.uid()
    AND is_admin = true
  );
$function$
;

CREATE OR REPLACE FUNCTION public.log_prompt()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  RAISE LOG 'New prompt: %', NEW.prompt;
  RAISE LOG 'Parameters: ratio=%, strength=%, steps=%, guidance=%, outputs=%',
    NEW.aspect_ratio, NEW.prompt_strength, NEW.steps, NEW.guidance_scale, NEW.num_outputs;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.purchase_credits(profile_id uuid, amount integer, stripe_payment_id text, price_paid numeric)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    -- Enregistrer la source
    INSERT INTO credit_sources (
        profile_id, type, amount, metadata
    ) VALUES (
        profile_id,
        'stripe_purchase',
        amount,
        jsonb_build_object(
            'stripe_payment_id', stripe_payment_id,
            'price_paid', price_paid
        )
    );

    -- Ajouter les crédits
    PERFORM update_credits_balance(
        profile_id,
        amount,
        'purchase',
        'Achat de crédits via Stripe'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reset_daily_ads()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    UPDATE profiles 
    SET ads_watched_today = 0 
    WHERE DATE(ads_last_watched) < CURRENT_DATE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_credits_balance(profile_id uuid, amount integer, type text, description text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    INSERT INTO credits_transactions (profile_id, amount, type, description)
    VALUES ($1, $2, $3, $4);

    UPDATE profiles 
    SET credits_balance = credits_balance + $2,
        lifetime_credits = CASE WHEN $2 > 0 THEN lifetime_credits + $2 ELSE lifetime_credits END,
        last_credit_update = now()
    WHERE id = $1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_profile_on_sign_in()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    UPDATE public.profiles
    SET last_sign_in_at = NEW.last_sign_in_at,
        email = COALESCE(NEW.email, profiles.email)
    WHERE id = NEW.id;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_reference_image_usage()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    update reference_images
    set 
        last_used_at = now(),
        usage_count = usage_count + 1
    where id = new.id;
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_subscription(profile_id uuid, tier text, status text, end_date timestamp without time zone DEFAULT NULL::timestamp without time zone)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    INSERT INTO subscription_history (
        profile_id, tier, status, start_date, end_date
    )
    VALUES ($1, $2, $3, now(), $4);

    UPDATE profiles 
    SET subscription_tier = $2,
        subscription_status = $3,
        subscription_end_date = COALESCE($4, 
            CASE WHEN $2 = 'free' THEN NULL 
            ELSE now() + interval '1 month'
            END
        )
    WHERE id = $1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    new.updated_at = now();
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_user_stats()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    update profiles
    set total_generations = total_generations + 1
    where id = new.user_id;
    return new;
end;
$function$
;

create or replace view "public"."user_generation_stats" as  SELECT generated_images.user_id,
    count(*) AS total_generations,
    count(DISTINCT date_trunc('day'::text, generated_images.created_at)) AS active_days,
    avg(generated_images.generation_time) AS avg_generation_time,
    count(
        CASE
            WHEN (generated_images.status = 'completed'::image_status) THEN 1
            ELSE NULL::integer
        END) AS successful_generations,
    count(
        CASE
            WHEN (generated_images.status = 'failed'::image_status) THEN 1
            ELSE NULL::integer
        END) AS failed_generations
   FROM generated_images
  GROUP BY generated_images.user_id;


CREATE OR REPLACE FUNCTION public.watch_ad(profile_id uuid, ad_id text, duration integer, platform text DEFAULT 'web'::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    credits_to_earn integer := 5; -- Crédits de base par pub
    user_limit integer;
BEGIN
    -- Récupérer la limite quotidienne de l'utilisateur
    SELECT daily_ads_limit INTO user_limit
    FROM profiles
    WHERE id = profile_id;

    -- Vérifier la limite quotidienne
    IF (SELECT ads_watched_today FROM profiles WHERE id = profile_id) >= user_limit THEN
        RETURN false;
    END IF;

    -- Bonus pour longue durée de visionnage
    IF duration >= 30 THEN
        credits_to_earn := credits_to_earn + 2;
    END IF;

    -- Enregistrer le visionnage
    INSERT INTO ads_history (
        profile_id,
        ad_id,
        credits_earned,
        watched_duration,
        completed,
        platform
    )
    VALUES (
        profile_id,
        ad_id,
        credits_to_earn,
        duration,
        duration >= 30,
        platform
    );

    -- Mettre à jour le profil
    UPDATE profiles 
    SET credits_balance = credits_balance + credits_to_earn,
        ads_credits_earned = ads_credits_earned + credits_to_earn,
        ads_watched_today = ads_watched_today + 1,
        ads_last_watched = now()
    WHERE id = profile_id;

    RETURN true;
END;
$function$
;

grant select on table "public"."Amethyst" to "authenticated";

grant delete on table "public"."Amethyst" to "service_role";

grant insert on table "public"."Amethyst" to "service_role";

grant references on table "public"."Amethyst" to "service_role";

grant select on table "public"."Amethyst" to "service_role";

grant trigger on table "public"."Amethyst" to "service_role";

grant truncate on table "public"."Amethyst" to "service_role";

grant update on table "public"."Amethyst" to "service_role";

grant select on table "public"."ad_views" to "authenticated";

grant delete on table "public"."ad_views" to "service_role";

grant insert on table "public"."ad_views" to "service_role";

grant references on table "public"."ad_views" to "service_role";

grant select on table "public"."ad_views" to "service_role";

grant trigger on table "public"."ad_views" to "service_role";

grant truncate on table "public"."ad_views" to "service_role";

grant update on table "public"."ad_views" to "service_role";

grant select on table "public"."ads_history" to "authenticated";

grant delete on table "public"."ads_history" to "service_role";

grant insert on table "public"."ads_history" to "service_role";

grant references on table "public"."ads_history" to "service_role";

grant select on table "public"."ads_history" to "service_role";

grant trigger on table "public"."ads_history" to "service_role";

grant truncate on table "public"."ads_history" to "service_role";

grant update on table "public"."ads_history" to "service_role";

grant select on table "public"."collection_images" to "authenticated";

grant delete on table "public"."collection_images" to "service_role";

grant insert on table "public"."collection_images" to "service_role";

grant references on table "public"."collection_images" to "service_role";

grant select on table "public"."collection_images" to "service_role";

grant trigger on table "public"."collection_images" to "service_role";

grant truncate on table "public"."collection_images" to "service_role";

grant update on table "public"."collection_images" to "service_role";

grant select on table "public"."credit_sources" to "authenticated";

grant delete on table "public"."credit_sources" to "service_role";

grant insert on table "public"."credit_sources" to "service_role";

grant references on table "public"."credit_sources" to "service_role";

grant select on table "public"."credit_sources" to "service_role";

grant trigger on table "public"."credit_sources" to "service_role";

grant truncate on table "public"."credit_sources" to "service_role";

grant update on table "public"."credit_sources" to "service_role";

grant select on table "public"."credits_transactions" to "authenticated";

grant delete on table "public"."credits_transactions" to "service_role";

grant insert on table "public"."credits_transactions" to "service_role";

grant references on table "public"."credits_transactions" to "service_role";

grant select on table "public"."credits_transactions" to "service_role";

grant trigger on table "public"."credits_transactions" to "service_role";

grant truncate on table "public"."credits_transactions" to "service_role";

grant update on table "public"."credits_transactions" to "service_role";

grant select on table "public"."generated_images" to "authenticated";

grant delete on table "public"."generated_images" to "service_role";

grant insert on table "public"."generated_images" to "service_role";

grant references on table "public"."generated_images" to "service_role";

grant select on table "public"."generated_images" to "service_role";

grant trigger on table "public"."generated_images" to "service_role";

grant truncate on table "public"."generated_images" to "service_role";

grant update on table "public"."generated_images" to "service_role";

grant select on table "public"."image_collections" to "authenticated";

grant delete on table "public"."image_collections" to "service_role";

grant insert on table "public"."image_collections" to "service_role";

grant references on table "public"."image_collections" to "service_role";

grant select on table "public"."image_collections" to "service_role";

grant trigger on table "public"."image_collections" to "service_role";

grant truncate on table "public"."image_collections" to "service_role";

grant update on table "public"."image_collections" to "service_role";

grant select on table "public"."image_metadata" to "authenticated";

grant delete on table "public"."image_metadata" to "service_role";

grant insert on table "public"."image_metadata" to "service_role";

grant references on table "public"."image_metadata" to "service_role";

grant select on table "public"."image_metadata" to "service_role";

grant trigger on table "public"."image_metadata" to "service_role";

grant truncate on table "public"."image_metadata" to "service_role";

grant update on table "public"."image_metadata" to "service_role";

grant select on table "public"."images" to "authenticated";

grant delete on table "public"."images" to "service_role";

grant insert on table "public"."images" to "service_role";

grant references on table "public"."images" to "service_role";

grant select on table "public"."images" to "service_role";

grant trigger on table "public"."images" to "service_role";

grant truncate on table "public"."images" to "service_role";

grant update on table "public"."images" to "service_role";

grant select on table "public"."oauth_tokens" to "authenticated";

grant delete on table "public"."oauth_tokens" to "service_role";

grant insert on table "public"."oauth_tokens" to "service_role";

grant references on table "public"."oauth_tokens" to "service_role";

grant select on table "public"."oauth_tokens" to "service_role";

grant trigger on table "public"."oauth_tokens" to "service_role";

grant truncate on table "public"."oauth_tokens" to "service_role";

grant update on table "public"."oauth_tokens" to "service_role";

grant select on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."prompts" to "anon";

grant insert on table "public"."prompts" to "anon";

grant references on table "public"."prompts" to "anon";

grant select on table "public"."prompts" to "anon";

grant trigger on table "public"."prompts" to "anon";

grant truncate on table "public"."prompts" to "anon";

grant update on table "public"."prompts" to "anon";

grant delete on table "public"."prompts" to "authenticated";

grant insert on table "public"."prompts" to "authenticated";

grant references on table "public"."prompts" to "authenticated";

grant select on table "public"."prompts" to "authenticated";

grant trigger on table "public"."prompts" to "authenticated";

grant truncate on table "public"."prompts" to "authenticated";

grant update on table "public"."prompts" to "authenticated";

grant delete on table "public"."prompts" to "service_role";

grant insert on table "public"."prompts" to "service_role";

grant references on table "public"."prompts" to "service_role";

grant select on table "public"."prompts" to "service_role";

grant trigger on table "public"."prompts" to "service_role";

grant truncate on table "public"."prompts" to "service_role";

grant update on table "public"."prompts" to "service_role";

grant select on table "public"."reference_images" to "authenticated";

grant delete on table "public"."reference_images" to "service_role";

grant insert on table "public"."reference_images" to "service_role";

grant references on table "public"."reference_images" to "service_role";

grant select on table "public"."reference_images" to "service_role";

grant trigger on table "public"."reference_images" to "service_role";

grant truncate on table "public"."reference_images" to "service_role";

grant update on table "public"."reference_images" to "service_role";

grant select on table "public"."subscription_history" to "authenticated";

grant delete on table "public"."subscription_history" to "service_role";

grant insert on table "public"."subscription_history" to "service_role";

grant references on table "public"."subscription_history" to "service_role";

grant select on table "public"."subscription_history" to "service_role";

grant trigger on table "public"."subscription_history" to "service_role";

grant truncate on table "public"."subscription_history" to "service_role";

grant update on table "public"."subscription_history" to "service_role";

create policy "Lecture vues de pubs"
on "public"."ad_views"
as permissive
for select
to authenticated
using (((profile_id = auth.uid()) OR ( SELECT profiles.is_admin
   FROM profiles
  WHERE (profiles.id = auth.uid()))));


create policy "Lecture de son historique de pubs"
on "public"."ads_history"
as permissive
for select
to authenticated
using (((profile_id = auth.uid()) OR ( SELECT profiles.is_admin
   FROM profiles
  WHERE (profiles.id = auth.uid()))));


create policy "Lecture sources de crédits"
on "public"."credit_sources"
as permissive
for select
to authenticated
using (((profile_id = auth.uid()) OR ( SELECT profiles.is_admin
   FROM profiles
  WHERE (profiles.id = auth.uid()))));


create policy "Lecture de ses propres transactions"
on "public"."credits_transactions"
as permissive
for select
to authenticated
using (((profile_id = auth.uid()) OR ( SELECT profiles.is_admin
   FROM profiles
  WHERE (profiles.id = auth.uid()))));


create policy "Users can create their own generated images"
on "public"."generated_images"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can view their own generated images"
on "public"."generated_images"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Users can view public collections"
on "public"."image_collections"
as permissive
for select
to public
using ((is_public OR (auth.uid() = user_id)));


create policy "Lecture de ses tokens OAuth"
on "public"."oauth_tokens"
as permissive
for select
to authenticated
using (((profile_id = auth.uid()) OR ( SELECT profiles.is_admin
   FROM profiles
  WHERE (profiles.id = auth.uid()))));


create policy "anon_profiles_select"
on "public"."profiles"
as permissive
for select
to anon
using (true);


create policy "profiles_select"
on "public"."profiles"
as permissive
for select
to authenticated
using (((id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM profiles profiles_1
  WHERE ((profiles_1.id = auth.uid()) AND (profiles_1.is_admin = true))))));


create policy "profiles_update"
on "public"."profiles"
as permissive
for update
to authenticated
using (((id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM profiles profiles_1
  WHERE ((profiles_1.id = auth.uid()) AND (profiles_1.is_admin = true))))))
with check (((id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM profiles profiles_1
  WHERE ((profiles_1.id = auth.uid()) AND (profiles_1.is_admin = true))))));


create policy "service_role_full_access"
on "public"."profiles"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "service_role_policy"
on "public"."profiles"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "users_read_own"
on "public"."profiles"
as permissive
for select
to authenticated
using (((id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM profiles profiles_1
  WHERE ((profiles_1.id = auth.uid()) AND (profiles_1.is_admin = true))))));


create policy "users_update_own"
on "public"."profiles"
as permissive
for update
to authenticated
using ((id = auth.uid()))
with check ((id = auth.uid()));


create policy "Users can insert their own prompts"
on "public"."prompts"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can view their own prompts"
on "public"."prompts"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Users can create their own reference images"
on "public"."reference_images"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can view their own reference images"
on "public"."reference_images"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Lecture de son historique d'abonnement"
on "public"."subscription_history"
as permissive
for select
to authenticated
using (((profile_id = auth.uid()) OR ( SELECT profiles.is_admin
   FROM profiles
  WHERE (profiles.id = auth.uid()))));


CREATE TRIGGER on_image_generated AFTER INSERT ON public.generated_images FOR EACH ROW EXECUTE FUNCTION update_user_stats();

CREATE TRIGGER log_prompt_trigger AFTER INSERT ON public.prompts FOR EACH ROW EXECUTE FUNCTION log_prompt();

CREATE TRIGGER on_reference_image_used AFTER UPDATE OF last_used_at ON public.reference_images FOR EACH ROW EXECUTE FUNCTION update_reference_image_usage();


